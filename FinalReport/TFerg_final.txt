Thomas Ferguson
Dr. Tom Carter
May 23rd, 2017
CS 4300 – 001

Compiler Project – Final Individual Report

I learned a ton from doing this project, but about the C language – which I have grown to respect and actually enjoy – and about compilation.  Initially it was very overwhelming, as I wasn’t sure how everything was supposed to go together, but after that initial hurdle how to go about implementing the compiler became clear – at least at a general level.  The initial goal was just to get the Flex and Yacc code to actually compile successfully, which was realized fairly early on.  
Once we could get the compiler to parse through a basic “hello, world” program without crashing or throwing syntax errors, we started to work on generating VMQ code.  The implementation started off very hacky (it still is, but a bit less so than the initial version), as some of the VMQ setup statements were hardcoded into the VMQ file, namely the runtime initialization op, as well as the stack frame creation op.  While trying to get “hello, world” running, the primary issue I had was how to keep track of the strings and their VMQ memory locations.  
I eventually came up with the solution of just storing all of the strings literals that Flex came across in a global linked list, and I calculated the VMQ memory locations by just starting strings off at location 0 and subsequent strings having the memory location of the previous string, plus the length of the previous string (plus/minus a constant I think, I don’t remember the specific implementation).  This approach had the extra benefit of working with any string output.  Additionally, VMQ memory was conserved as strings were first checked to exist before being appended to the string-literal linked list.
After “hello, world” was working, my goal was to get the basic math operations working in output statements (support for variables wasn’t implemented yet).  This was very eye opening for me, as it allowed me to learn (through a lot of trial and error) how the AST is constructed, as well as how to traverse it in the various switch cases within the eval function.  The tree is primarily traversed with in-order traversal, starting with the left child, but some parts of it are traversed by first going to the right child, such as with pushing values onto the stack prior to a function call.
Implementing math operations introduced me to the challenge of creating a system that would properly track and use temporary variables for intermediate calculations.  This ended up being very useful toward implementing variables a bit later.  Additionally, I also had to track integer literals and their VMQ memory locations, as to my understanding VMQ math operations don’t actually take literal values directly as operands, but rather the address of the desired value.  The tracking of integer literals was implemented in much the same way as string literals.  At this stage, I ended up just appending any integer literals to the end of the string literal space in VMQ global memory, making sure to start them at the first even memory address.  
After math ops were implemented, I moved on to variables.  This wasn’t terribly difficult, as it uses a lot of the same ideas from the implementation of string literals and math ops.  At this stage, global variables were appended to the end of integer literals and any local variables simply added to the count of the size of whatever function they were a part of.  Due to how the target language is defined, variable definitions cannot occur after statements, so first the space for local variables in counted up, then the function is evaluated and the maximum number of temporary variables needed is tracked.  After the function is completely evaluated, the two numbers (local variables and temporary variables) are added up and multiplied by 2 (we never implemented float, otherwise this would need to be mindful of 32-bit floats) and tacked the number onto the end of the stack frame op.  
After variables was working, I set out to get multiple functions with function calls working.  This introduced the challenge of having to keep track of VMQ line numbers, as both function calls and the runtime initialization require VMQ labels.  To address this issue, I created yet another global linked list (strings, integers, variables, and control structures all have their own as well) for functions, which contains nodes that hold information that is needed to track things important to each function.  Such information includes:  starting VMQ line number, the function’s number of VMQ lines, name of the function (so we can identify main), and the number of variables and temporary variables needed by the function.  Every time a VMQ statement is generated in the eval function, it appends the string to the current function’s VMQ list and increments the line counter.  The next function’s VMQ start line is just the previous function’s start line, plus the number of lines of the previous function (plus or minus a constant, I think).  
Functional calls presented a bit of a challenge, as I had to implement parameter passing to get this to work.  I had a hard time understanding the VMQ code for parameters, and I still don’t fully understand the intricacies of the various addressing modes.  I relied largely on the example code in the VMQ documentation, and just mimicked when and where to use the correct addressing mode.  Parameter passing itself wasn’t too difficult to implement, as I was already doing it for output function calls.  During this stage I also implemented cin, as I had forgotten about it, but it was very easy to include it at this point.
After function calls and parameter passing were implemented I moved on to while loops.  This presented an even larger challenge than anticipated, since relational operations needed to be implemented before loops could be.  I spent a good few days working out how to translate something as simple as (x < 3) to VMQ code, but eventually came up with a solution, though it is less than ideal.  For instance, it does not support short-circuiting – it will evaluate the entire statement.  The system works by testing the relational operator in the boolean expression, and storing the result (0 for false, 1 for true) in a temporary variable.  A final conditional statement tests the temporary variable to see if it is equal to 0:  if it is then program control jumps past the true-block, if it isn’t then the true-block is allowed to execute.
One of the main challenges of loops was that the final conditional statement needs a jump line number, but it doesn’t know ahead of time how long the body of the loop will be.  The solution I implemented was to create yet another linked list of structs I named control_nodes.  A control_node has three linked lists, which will be used to temporary contain the VMQ statements generated for the boolean expression, the execute-if-true statements, and the execute-if-false statements.  The control node also has three counters, which track the number of lines generated for each list.  In the case of while loops, the final conditional statement that checks to see if the temporary variable is set to true or false is added after the code for the true statement is generated and counted – this allows the compiler to know the line number for the statement to jump to once looping should stop.
That’s the bulk of it.  I really enjoyed working on this project; it was frustrating at times but very challenging.
